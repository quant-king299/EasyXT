# 聚宽API文档

来源: [聚宽API文档PDF](https://cdn.joinquant.com/help/img/JoinQuantAPI.pdf)

## 第1页

API文档 感谢您使用JoinQuant（聚宽）量化交易平台，以下内容主要介绍聚宽量化交易平台的API使用方法，目录中 带有”” 标识的API是 "回测环境/模拟" 的专用API，不能在研究模块中调用 内容较多，可使用Ctrl+F 进行搜索 如果以下内容仍没有解决您的问题，请您通过社区提问的方式告诉我们，谢谢 开始写策略 简单但是完整的策略 先来看一个简单但是完整的策略: def initialize(context): # 定义一个全局变量, 保存要操作的股票 g.security = '000001.XSHE' # 运行函数 run_daily(market_open, time='every_bar') def market_open(context): if g.security not in context.portfolio.positions: order(g.security, 1000) else: order(g.security, -800) 一个完整策略只需要两步: 设置初始化函数: initialize,上面的例子中, 只操作一支股票: ‘000001.XSHE’, 平安银行 实现一个函数, 来根据历史数据调整仓位. 这个策略里, 每当我们没有股票时就买入1000股, 每当我们有股票时又卖出800股, 具体的下单API请看order函 数. 这个策略里, 我们有了交易, 但是只是无意义的交易, 没有依据当前的数据做出合理的分析 下面我们来看一个真正实用的策略 实用的策略 在这个策略里, 我们会根据历史价格做出判断: 如果上一时间点价格高出五天平均价1%, 则全仓买入 如果上一时间点价格低于五天平均价, 则空仓卖出

## 第2页

# 导入聚宽函数库 import jqdata # 初始化函数，设定要操作的股票基准等等 def initialize(context): # 定义一个全局变量, 保存要操作的股票 # 000001(股票:平安银行) g.security = '000001.XSHE' # 设定沪深300作为基准 set_benchmark('000300.XSHG') # 开启动态复权模式(真实价格) set_option('use_real_price', True) # 运行函数 run_daily(market_open, time='every_bar') # 每个单位时间(如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次)调用一次 def market_open(context): security = g.security # 获取股票的收盘价 close_data = attribute_history(security, 5, '1d', ['close']) # 取得过去五天的平均价格 MA5 = close_data['close'].mean() # 取得上一时间点价格 current_price = close_data['close'][-1] # 取得当前的现金 cash = context.portfolio.cash # 如果上一时间点价格高出五天平均价1%, 则全仓买入 if current_price > 1.01*MA5: # 用所有 cash 买入股票 order_value(security, cash) # 记录这次买入 log.info("Buying %s" % (security)) # 如果上一时间点价格低于五天平均价, 则空仓卖出 elif current_price < MA5 and context.portfolio.positions[security].closea ble_amount > 0: # 卖出所有股票,使这只股票的最终持有量为0 order_target(security, 0) # 记录这次卖出 log.info("Selling %s" % (security)) # 画出上一时间点价格 record(stock_price=current_price) 用户需要实现的函数 initialize initialize(context)

## 第3页

初始化方法，在整个回测模拟实盘中最开始执行一次，用于初始一些全局变量 参数 context: Context对象, 存放有当前的账户/股票持仓信息 返回 None 示例 def initialize(context): # g为全局变量 g.security = "000001.XSHE" 定时运行函数, 可选 run_monthly run_weekly run_daily def initialize(context): # 按月运行 run_monthly(func, monthday, time='open', reference_security) # 按周运行 run_weekly(func, weekday, time='open', reference_security) # 每天内何时运行 run_daily(func, time='open', reference_security) 具体参见定时运行 参数 参数 解释 func 一个函数, 此函数必须接受context参数 monthday 每月的第几个交易日, 可以是负数, 表示倒数第几个交易日如果超出每月总交易日个 数，则取临近的交易日执行（具体见下方注意中的示例） weekday 每周的第几个交易日, 可以是负数, 表示倒数第几个交易日如果超出每周总交易日个 数，则取临近的交易日执行（具体见下方注意中的示例） time 一个字符串,可以是具体执行时间,支持 time 表达式比如 “10:00”, “01:00”, 或者 “every_bar”, “open”, “before_open”, “after_close”, “morning” 和 “night”(具体执行 时间如见下方) time 表达式具有 ‘base +/-offset’ 的形式，如：’open-30m’表示开盘前30分 钟，’close+1h30m’表示收盘后一小时三十分钟当使用 ‘base +/-offset’ 形式的表达 式时， base 只能使用 open 或 close 二者之一

## 第4页

参数 解释 reference_security 时间的参照标的 如参照 ‘000001.XSHG’，交易时间为 9:30-15:00 如参照’IF1512.CCFX’，2016-01-01之后的交易时间为 9:30-15:00，在此之前为 9:15-15:15 如参照’A9999.XDCE’，因为有夜盘，因此开始时间为21:00，结束时间为15:00 time 具体执行时间 具体时间 24小时内的任意时间，如”10:00”, “01:00” every_bar 只能在 run_daily 中调用； 按天会在每天的开盘时调用一次，按分钟会在每天的每分钟运 行 open 开盘时运行(等同于”9:30”) before_open 早上 9:00 运行 after_close 下午 15:30 运行 morning 早上 8:00 运行 night 晚上 20:00 运行 返回 None 示例

## 第5页

def weekly(context): print 'weekly %s %s' % (context.current_dt, context.current_dt.isoweekday ()) def monthly(context): print 'monthly %s %s' % (context.current_dt, context.current_dt.month) def daily(context): print 'daily %s' % context.current_dt def initialize(context): # 指定每月第一个交易日, 在开盘后一小时10分钟执行 run_monthly(monthly, 1, 'open + 1h10m') # 指定每天收盘前10分钟运行 run_weekly(daily, 'close - 10m') # 指定每天收盘后执行 run_daily(daily, 'after_close') # 指定在每天的10:00运行 run_daily(daily, '10:00') # 参照股指期货的时间每分钟运行一次, 必须选择分钟回测, 否则每天执行 run_daily(daily, 'every_bar', reference_security='IF1512.CCFX') handle_data, 可选 handle_data(context, data) 该函数每个单位时间会调用一次, 如果按天回测,则每天调用一次,如果按分钟,则每分钟调用一次 该函数依据的时间是股票的交易时间，即 9:30 - 15:00. 期货请使用定时运行函数 该函数在回测中的非交易日是不会触发的（如回测结束日期为2016年1月5日，则程序在2016年1月1日-3日 时，handle_data不会运行，4日继续运行） 对于使用当日开盘价撮合的日级模拟盘，在9:25集合竞价完成时就可以获取到开盘价，出于减少并发运行模 拟盘数量的目的，我们会提前到9:279:30之间运行, 策略类获取到逻辑时间(context.current_dt)仍然是 9:30 参数 context: Context对象, 存放有当前的账户/标的持仓信息 data: 一个字典(dict), key是股票代码, value是当时的SecurityUnitData 对象. 存放前一个单位时间(按天回测, 是前一天, 按分钟回测, 则是前一分钟) 的数据. 注意:

## 第6页

为了加速, data 里面的数据是按需获取的, 每次 handle_data 被调用时, data 是空的 dict, 当你使用 data[security] 时该 security 的数据才会被获取. data 只在这一个时间点有效, 请不要存起来到下一个 handle_data 再用 注意, 要获取回测当天的开盘价/是否停牌/涨跌停价, 请使用 get_current_data 返回 None 示例 def handle_data(context, data): order("000001.XSHE",100) before_trading_start, 可选 before_trading_start(context) 该函数会在每天开始交易前被调用一次, 您可以在这里添加一些每天都要初始化的东西. 该函数依据的时间是股票的交易时间，即该函数启动时间为 9:20. 期货请使用定时运行函数，time 参数设定 为’before_open’  参数 context: Context对象, 存放有当前的账户/股票持仓信息 返回 None 示例 def before_trading_start(context): log.info(str(context.current_dt)) after_trading_end, 可选 after_trading_end(context) 该函数会在每天结束交易后被调用一次, 您可以在这里添加一些每天收盘后要执行的内容. 这个时候所有未完 成的订单已经取消. 该函数依据的时间是股票的交易时间，即该函数启动时间为 15:10. 期货请使用定时运行函数，time 参数设 定为’after_close’  参数 context: Context对象, 存放有当前的账户/股票持仓信息

## 第7页

返回 None 示例 def after_trading_end(context): log.info(str(context.current_dt)) process_initialize, 可选 process_initialize(context) 该函数会在每次模拟盘/回测进程重启时执行, 一般用来初始化一些不能持久化保存的内容. 在 initialize 后执行. 因为模拟盘会每天重启, 所以这个函数会每天都执行. 参数 context: Context对象, 存放有当前的账户/股票持仓信息 返回 None 示例 def process_initialize(context): # query 对象不能被 pickle 序列化, 所以不能持久保存, 所以每次进程重启时都给它初始 化 # 以两个下划线开始, 系统序列化 [g] 时就会自动忽略这个变量, 更多信息, 请看 [g] 和 [模拟盘注意事项] g.__q = query(valuation) def handle_data(context, data): get_fundamentals(g.__q) on_strategy_end, 可选 def on_strategy_end(context) 在回测模拟交易正常结束时被调用， 失败时不会被调用 在模拟交易到期结束时也会被调用， 手动在到期前关闭不会被调用 参数 context: Context对象, 存放有当前的账户/股票持仓信息 返回 None

## 第8页

示例 def on_strategy_end(context): print '回测结束' after_code_changed, 可选 after_code_changed(context) 模拟盘在每天的交易时间结束后会休眠，第二天开盘时会恢复，如果在恢复时发现代码已经发生了修改，则 会在恢复时执行这个函数 具体的使用场景：可以利用这个函数修改一些模拟盘的数据 注意: 因为一些原因, 执行回测时这个函数也会被执行一次, 在 process_initialize 执行完之后执行. 参数 context: Context对象, 存放有当前的账户/股票持仓信息 返回 None 示例 def after_code_changed(context): g.stock = '000001.XSHE' 回测引擎介绍 回测环境 1. 回测引擎运行在Python2.7之上, 请您的策略也兼容Python2.7 2. 我们支持所有的Python标准库和部分常用第三方库, 具体请看: python库. 另外您可以把.py文件放在研 究根目录, 回测中可以直接import, 具体请看: 自定义python库 3. 安全是平台的重中之重, 您的策略的运行也会受到一些限制, 具体请看: 安全 回测过程 1. 准备好您的策略, 选择要操作的股票池, 实现handle_data函数 2. 选定一个回测开始和结束日期, 选择初始资金调仓间隔(每天还是每分钟), 开始回测 3. 引擎根据您选择的股票池和日期, 取得股票数据, 然后每一天或者每一分钟调用一次您的handle_data函 数, 同时告诉您现金持仓情况和股票在上一天或者分钟的数据. 在此函数中, 您还可以调用函数获取任 何多天的历史数据, 然后做出调仓决定. 4. 当您下单后, 我们会根据接下来时间的实际交易情况, 处理您的订单. 具体细节参见订单处理

## 第9页

5. 下单后您可以调用get_open_orders取得所有未完成的订单, 调用cancel_order取消订单 6. 您可以在handle_data里面调用record()函数记录某些数据, 我们会以图表的方式显示在回测结果页面 7. 您可以在任何时候调用log.info/debug/warn/error函数来打印一些日志 8. 回测结束后我们会画出您的收益和基准(参见set_benchmark)收益的曲线, 列出每日持仓,每日交易和一 系列风险数据 数据 1. 股票数据：我们拥有所有A股上市公司2005年以来的股票行情数据市值数据财务数据上市公司基 本信息融资融券信息等为了避免幸存者偏差，我们包括了已经退市的股票数据 2. 基金数据：我们目前提供了600多种在交易所上市的基金的行情净值等数据，包含ETFLOF分级 A/B基金以及货币基金的完整的行情净值数据等，请点击基金数据查看 3. 金融期货数据：我们提供中金所推出的所有金融期货产品的行情数据，并包含历史产品的数据 4. 股票指数：我们支持近600种股票指数数据，包括指数的行情数据以及成分股数据为了避免未来函 数，我们支持获取历史任意时刻的指数成分股信息，具体见get_index_stocks注意：指数不能买卖 5. 行业板块：我们支持按行业按板块选股，具体见get_industry_stocks 6. 概念板块：我们支持按概念板块选股，具体见get_concept_stocks 7. 宏观数据：我们提供全方位的宏观数据，为投资者决策提供有力数据支持 8. 所有的行情数据我们均已处理好前复权信息 9. 我们当日的回测数据会在收盘后通过多数据源进行校验，并在T+1（第二天）的00:01更新 安全 1. 保证您的策略安全是我们的第一要务 2. 在您使用我们网站的过程中, 我们全程使用https传输 3. 策略会加密存储在数据库 4. 回测时您的策略会在一个安全的进程中执行, 我们使用了进程隔离的方案来确保系统不会被任何用户的 代码攻击, 每个用户的代码都运行在一个有很强限制的进程中: 只能读指定的一些python库文件 不能写和执行任何文件, 如果您需要保存和读取私有文件, 请看[write_file]/[read_file] 不能创建进程或者线程 限制了cpu和内存, 堆栈的使用 可以访问网络, 但是对带宽做了限制, 下载最大带宽为500KB/s, 上传带宽为10KB/s 有严格的超时机制, 如果handle_data超过30分钟则立即停止运行 对于读取回测所需要的数据, 和输出回测结果, 我们使用一个辅助进程来帮它完成, 两者之间通过 管道连接. 我们使用了linux内核级别的apparmer技术来实现这一点. 有了这些限制我们确保了任何用户不能侵入我们的系统, 更别提盗取他人的策略了. 运行频率 1. Bar 的概念 在一定时间段内的时间序列就构成了一根 K 线（日本蜡烛图），单根 K 线被称为 Bar

## 第10页

如果是一分钟内的 Tick 序列，即构成一根分钟 K 线，又称分钟 Bar; 如果是一天内的分钟序列，即构成一根日线 K 线，又称日线 Bar; Bar 的示意图如下所示： Bar 就是时间维度上，价格在空间维度上变化构成的数据单元如下图所示，多个数据单元 Bar 构成的一个 时间序列 2. 频率详解 下列图片中齿轮为 handle_data(context, data) 的运行时间，before_trading_start(context) 等其他函数运行 时间详见相关API 频率：天 当选择天频率时， 算法在每根日线 Bar 都会运行一次，即每天运行一次 在算法中，可以获取任何粒度的数据

## 第11页

频率：分钟 当选择分钟频率时， 算法在每根分钟 Bar 都会运行一次，即每分钟运行一次 在算法中，可以获取任何粒度的数据 频率：Tick 当选择 Tick 频率时，每当新来一个 Tick，算法都会被执行一次 注意：现阶段，Tick 频率只有在模拟交易时可以选择 执行示意图如下图所示：

## 第12页

订单处理 对于您在某个单位时间下的单, 我们会做如下处理: 回测 使用Bar撮合 市价单: 按天回测 当 “最新价+滑点” 在涨跌停范围内，则进行撮合，反之撤销 交易价格: 开盘价 + 滑点 最大成交量: 每次下单成交量不会超过该股票当天的总成交量. 可通过选项 order_volume_ratio 设置每天最大的成交量, 例如: 0.25 表示下单成交量不会超过当天成 交量的 25% 注意: context.portfolio 中的持仓价格会使用当天开盘价更新 data 是昨天的按天数据, 要想拿到当天开盘价, 请使用 get_current_data 拿取 day_open 字段 - 分钟回测 - 当 “最新价+滑点” 在涨跌停范围内，则进行撮合，反之撤销 - 交易价格: 因为我们是在每分钟的第一秒钟执行代码, 所以价格是上一分钟的最后一个价格 + [滑点] - 同按天回测规则, 每次下单成交量不会超过该股票当天的总成交量, [order_volume_rati o] 同样有效.注意: 这是限制了每个订单的成交量, 当然, 你可以通过一天多次下单来超过一天成 交量, 但是, 为了对你的回测负责, 请不要这么做. 所有市价单下单之后同步完成(也即 order_XXX 系列函数返回时完成), context.portfolio 会同 步变化

## 第13页

限价单 回测(天分钟): 当 委托价 > 最新价+滑点，按市价单模式撮合 当 委托价 <= 最新价+滑点，则挂单，在Bar结束时按照Bar信息进行撮合： 当 委托价 > bar 的最低价，则成交价为委托价，成交量不超过 Bar 成交量 * order_volume_ratio 天分钟相同 不是立即完成, 下单之后 context.portfolio.cash 和 context.portfolio.positions 不会同步变化. 按天模拟交易暂时不支持限价单 上述过程中, 如果实际价格已经涨停或者跌停, 则相对应的买单或卖单不成交, 市价单直接取消(log中有警告信 息), 限价单会挂单直到可以成交. 一天结束后, 所有未完成的订单会被取消 每次订单完成(完全成交)或者取消后, 我们会根据成交量计算手续费(参见set_order_cost), 减少您的现金 更多细节, 请看order函数 模拟交易 模拟交易默认开启盘口撮合模式可通过[设置是否开启盘口撮合模式]进行设定，决定您定的模拟交易使用盘 口还是 Bar 进行撮合 1.使用盘口撮合 市价单 买单： 根据卖单盘口进行撮合 优先从卖一档开始撮合，根据成交量算出 加权均价 成交价： 加权均价 5档成交剩余撤销：买入时从“卖一”到“卖五”价格依次成交，卖出时从“买一”到“买五”价格 依次成交若无法全部成交，则剩余未匹配量自动撤销 当前没有盘口时，按照 使用 Bar 处理 处理： 当成交量不为零为，使用最新价+滑点成交 当成交量为零，则取消该订单 卖单： 根据买单盘口进行撮合 优先从买一档开始撮合，根据成交量算出 加权均价 成交价 ： 加权均价 5档成交剩余撤销：买入时从“卖一”到“卖五”价格依次成交，卖出时从“买一”到“买五”价格 依次成交若无法全部成交，则剩余未匹配量自动撤销 当前没有盘口时，按照 使用 Bar 处理 处理： 当成交量不为零为，使用最新价+滑点成交 当成交量为零，则取消该订单 限价单 买单： 根据卖单盘口进行撮合 优先从卖一档开始撮合，直至盘口价格>委托价的档位，根据成交量算出 加权均价

## 第14页

成交价 ： 加权均价 当限价单根据盘口撮合完，为部分成交时，剩余委托数量会在 Bar 结束时根据 Bar 信息 进行撮合，详情见Bar撮合方式 - 卖单： - 根据买单盘口进行撮合 - 优先从买一档开始撮合，直至盘口价格<委托价的档位，根据成交量算出 加权均价 - 成交价 ： 加权均价 - 当限价单根据盘口撮合完，为部分成交时，剩余委托数量会在 Bar 结束时根据 Bar 信息 进行撮合，详情见 Bar 撮合方式 注意：如模拟盘下限价委托单，并且根据盘口撮合后，订单为部分成交，则该订单完整信息在收盘时 更新 2.使用Bar撮合 市价单: 模拟交易 当 “最新价+滑点” 在涨跌停范围内，则进行撮合，反之撤销 交易价格: 最新价 + 滑点 最大交易量: 不管是按天, 按分钟, 还是按tick, 由于市价单都是同步完成, 下单那一刻无法 知道当天成交量, 所以市价单都不考虑成交量, 全量成交. - 所有市价单下单之后同步完成(也即 order_XXX 系列函数返回时完成), context.portfolio 会同步变化 限价单 模拟交易(天分钟Tick): 当 委托价 > 最新价+滑点，按市价单模式撮合 当 委托价 <= 最新价+滑点，则挂单，在Bar结束时按照Bar信息进行撮合： 当 委托价 > bar 的最低价，则成交价为委托价，成交量不超过 Bar 成交量 * order_volume_ratio 天分钟tick 相同 按tick, 不是立即完成, 而是下单之后每个tick根据这个tick的分价表撮合一次, 直到完 全成交或者当天收盘为止. 同样考虑 order_volume_ratio 选项. 注意：如模拟盘下限价委托单，订单信息会在收盘后更新 - 不是立即完成, 下单之后 context.portfolio.cash 和 context.portfolio.positions 不会同步变化. 按天模拟交易暂时不支持限价单

## 第15页

上述过程中, 如果实际价格已经涨停或者跌停, 则相对应的买单或卖单不成交, 市价单直接取消(log中有警告信 息), 限价单会挂单直到可以成交. 一天结束后, 所有未完成的订单会被取消 每次订单完成(完全成交)或者取消后, 我们会根据成交量计算手续费(参见set_order_cost), 减少您的现金 更多细节, 请看order函数 拆分合并和分红 传统前复权回测模式：当股票发生拆分，合并或者分红时，股票价格会受到影响，为了保证价格的连 续性, 我们使用前复权来处理之前的股票价格，给您的所有股票价格已经是前复权的价格 真实价格（动态复权）回测模式：当股票发生拆分，合并或者分红时，会按照历史情况，对账户进行 处理，会在账户账户中增加现金或持股数量发生变化，并会有日志提示 **注：**传统前复权回测模式 与 真实价格（动态复权）回测模式 区别[见这里](/post/1629) 股息红利税的计算 真实的税率计算方式如下： 分红派息的时候，不扣税； 等你卖出该只股票时，会根据你的股票持有时间（自你买进之日，算到你卖出之日的前一天，下同） 超过一年的免税2015年9月之前的政策是，满一年的收5%现在执行的是,2015年9月份的新优惠政 策：满一年的免税； 等你卖出股票时，你的持有时间在1个月以内（含1个月）的，补交红利的20%税款，券商会在你卖出 股票当日清算时直接扣收； 等你卖出股票时，你的持有时间在1个月至1年间（含1年）的，补交红利的10%税款，券商直接扣； 分次买入的股票，一律按照“先进先出”原则，对应计算持股时间； 当日有买进卖出的（即所谓做盘中T+0），收盘后系统计算你当日净额，净额为买入，则记录为今日新 买入净额为卖出，则按照先进先出原则，算成你卖出了你最早买入的对应数量持股，并考虑是否扣 税和税率问题 在回测及模拟交易中，由于需要在分红当天将扣税后的分红现金发放到账户，因此无法准确计算用户的持仓 时间（不知道股票卖出时间），我们的计算方式是，统一按照 20% 的税率计算的 滑点 在实战交易中，往往最终成交价和预期价格有一定偏差，因此我们加入了滑点模式来帮助您更好地模拟真实 市场的表现 您可以通过set_slippage来设置回测具体的滑点参数 交易税费 交易税费包含券商手续费和印花税您可以通过set_order_cost来设置具体的交易税费的参数 券商手续费

## 第16页

中国A股市场目前为双边收费，券商手续费系默认值为万分之三，即0.03%，最少5元 印花税 印花税对卖方单边征收，对买方不再征收，系统默认为千分之一，即0.1% 风险指标 风险指标数据有利于您对策略进行一个客观的评价 注意: 无论是回测还是模拟, 所有风险指标(年化收益/alpha/beta/sharpe/max_drawdown等指标)都只会每天更 新一次, 也只根据每天收盘后的收益计算, 并不考虑每天盘中的收益情况. 例外: 分钟和TICK模拟盘每分钟会更新策略收益和基准收益 按天模拟盘每天开盘后和收盘后会更新策略收益和基准收益 那么可能会造成这种现象: 模拟时收益曲线中有回撤, 但是 max_drawdown 可能为0. Total Returns（策略收益） 策略最终股票和现金的总价值 策略开始股票和现金的总价值 Total Annualized Returns（策略年化收益） 策略收益 策略执行天数 Benchmark Returns（基准收益） 基准最终价值 基准开始价值 Benchmark Annualized Returns（基准年化收益） 基准收益 策略执行天数 Alpha（阿尔法） 投资中面临着系统性风险（即Beta）和非系统性风险（即Alpha），Alpha是投资者获得与市场波动无关的回 报比如投资者获得了15%的回报，其基准获得了10%的回报，那么Alpha或者价值增值的部分就是5%

## 第17页

策略年化收益率 基准年化收益率 无风险利率（默认 ） 策略 值 Alpha值 解释 >0 策略相对于风险，获得了超额收益 =0 策略相对于风险，获得了适当收益 <0 策略相对于风险，获得了较少收益 Beta（贝塔） 表示投资的系统性风险，反映了策略对大盘变化的敏感性例如一个策略的Beta为1.5，则大盘涨1%的时 候，策略可能涨1.5%，反之亦然；如果一个策略的Beta为-1.5，说明大盘涨1%的时候，策略可能跌1.5%， 反之亦然 策略每日收益 基准每日收益 策略每日收益与基准每日收益的协方差 基准每日收益的方差 Beta值 解释 <0 投资组合和基准的走向通常反方向，如空头头寸类 =0 投资组合和基准的走向没有相关性，如固定收益类 0<<1 投资组合和基准的走向相同，但是比基准的移动幅度更小 =1 投资组合和基准的走向相同，并且和基准的移动幅度贴近 >1 投资组合和基准的走向相同，但是比基准的移动幅度更大 Sharpe（夏普比率） 表示每承受一单位总风险，会产生多少的超额报酬，可以同时对策略的收益与风险进行综合考虑 策略年化收益率

## 第18页

无风险利率（默认 ） 策略收益波动率 Sortino（索提诺比率） 表示每承担一单位的下行风险，将会获得多少超额回报 策略年化收益率 无风险利率（默认 ） 策略下行波动率 Information Ratio（信息比率） 衡量单位超额风险带来的超额收益信息比率越大，说明该策略单位跟踪误差所获得的超额收益越高，因 此，信息比率较大的策略的表现要优于信息比率较低的基准合理的投资目标应该是在承担适度风险下，尽 可能追求高信息比率 策略年化收益率 基准年化收益率 策略与基准每日收益差值的年化标准差 Algorithm Volatility（策略波动率） 用来测量策略的风险性，波动越大代表策略风险越高 策略每日收益率 策略每日收益率的平均值 策略执行天数 Benchmark Volatility（基准波动率） 用来测量基准的风险性，波动越大代表基准风险越高 基准每日收益率

## 第19页

基准每日收益率的平均值 基准执行天数 Max Drawdown（最大回撤） 描述策略可能出现的最糟糕的情况，最极端可能的亏损情况 策略某日股票和现金的总价值， Downside Risk（下行波动率） 策略收益下行波动率和普通收益波动率相比，下行标准差区分了好的和坏的波动 策略每日收益率 策略至第 日平均收益率 策略执行天数 胜率(%) 盈利次数在总交易次数中的占比 盈利交易次数 胜率 总交易次数 日胜率(%) 策略盈利超过基准盈利的天数在总交易数中的占比 当日策略收益跑赢当日基准收益的天数 日胜率 总交易日数 盈亏比 周期盈利亏损的比例 总盈利额 盈亏比 总亏损额

## 第20页

运行时间 开盘前(9:20)运行: run_monthly/run_weekly/run_daily中指定time=’before_open’运行的函数 before_trading_start 盘中运行: run_monthly/run_weekly/run_daily中在指定交易时间执行的函数, 执行时间为这分钟的第一秒. 例如: run_daily(func, '14:50') 会在每天的14:50:00(精确到秒)执行 handle_data 按日回测/模拟, 在9:30:00(精确到秒)运行, data为昨天的天数据 按分钟回测/模拟, 在每分钟的第一秒运行, 每天执行240次, 不包括11:30和15:00这两分钟, data是上一分钟的分钟数据. 例如: 当天第一次执行是在9:30:00, data是昨天14:59这一分 钟的分钟数据, 当天最后一次执行是在14:59:00, data是14:58这一分钟的分钟数据. 按tick模拟, 上午从9:30:00到11:29:55, 下午从13:00:00到14:59:55, 每5秒钟执行一次, 一 天执行240*12次. 例如: 当天第一次执行时在9:30:00, data为昨天最后5秒(14:59:55- 15:00:00)的数据(统计高开低收+成交量+成交额) 收盘后(15:00后半小时内)运行: run_monthly/run_weekly/run_daily中指定time=’after_close’运行的函数 after_trading_end 同一个时间点, 总是先运行 run_XXX 指定的函数, 然后是 before_trading_start, handle_data 和 after_trading_end 注意: run_XXX 指定的函数只能有一个参数 context, data 不再提供, 请使用 history/attribute_history 获取 initialize / before_trading_start / after_trading_end / handle_data 都是可选的, 如果不是必须 的, 不要实现这些函数, 一个空函数会降低运行速度. 模拟盘注意事项 模拟盘在每天运行结束后会保存状态, 结束进程(相当于休眠). 然后在第二天恢复. 进程结束时会保存这些状态: 用户账户, 持仓 使用 pickle 保存 g 对象. 注意 g 中以 ‘__’ 开头的变量将被忽略, 不会被保存 g 中不能序列化的变量不会被保存, 重启后会不存在. 如果你写了如下的代码: python def initialize(context): g.query = query(valuation) g 将不能被保存, 因为 query() 返回的对象并不能被持久化. 重启后也不会再执行 initialize, 使用 g.query 将会抛出 AttributeError 异常 正确的做法是, 在 process_initialize 中初始化它, 并且名字以 ‘__’ 开头. python

## 第21页

def process_initialize(context): g.__query = query(valuation) - 注意: 涉及到IO(打开的文件, 网络连接, 数据库连接)的对象是不能被序列化的: - query(valuation) : 数据库连接 - open("some/path") : 打开的文件 - requests.get('') : 网络连接 使用 [pickle] 保存 [context] 对象, 处理方式跟 [g] 一样 为了防止恶意攻击, 序列化之后的状态大小不能超过 30M, 如果超出将在保存状态时运行失败. 当超 过 20M 时日志中会有警告提示, 请注意日志. 恢复过程是这样的: 1. 加载策略代码, 因为python是动态语言, 编译即运行, 所以全局的(在函数外写的)代码会被执行一遍. 2. 使用保存的状态恢复 g, context, 和函数外定义的全局变量. 3. 执行 process_initialize, 每次启动时都会执行这个函数. 4. 如果策略代码和上一次运行时发生了修改，而且代码中定义了 after_code_changed 函数，则会运行 after_code_changed 函数 重启后不再执行 initialize 函数, initialize 函数在整个模拟盘的生命周期中只执行一次. 即使是更改回测后, initialize 也不会执行. 模拟盘更改回测之后上述的全局变量(包括 g 和 context 中保存的)不会丢失. 新代码中 initialize 不会执行. 如果需要修改原来的值, 可以在 after_code_changed 函数里面修改, 比如, 原来代码是: a = 1 def initialize(context): g.stock = '000001.XSHE' 代码改成: a = 2 def initialize(context): g.stock = '000002.XSHE' 执行时, a 仍然是 1, g.stock 仍然是 ‘000001.XSHE’, 要修改他们的值, 必须定义 after_code_changed: def after_code_changed(context): global a a = 2 g.stock = '000002.XSHE'

## 第22页

创建模拟交易时, 如果选择的日期是今天, 则从今天当前时间点开始运行, 应该在当前时间点之前运行的函数不 再运行. 比如: 今天10:00创建了按天的模拟交易, 选择日期是今天, 代码中实现了 handle_data 和 after_trading_end, 则 handle_data 今天不运行, 而 after_trading_end 会在 15:10 运行 当模拟交易在A时间点失败后, 然后在B时间点”重跑”, 那么 A-B 之间的时间点应该运行的函数不再运行 因为模拟盘资源有限, 为了防止用户创建之后长期搁置浪费资源, 我们做出如下限制: 如果一个模拟盘同时满足 下面条件, 则暂缓运行: 该用户连续30天没有使用JoinQuant网站 没有开启微信通知 当用户重新使用网站后, 第二天会继续运行(会把之前的交易日执行一遍, 并不会跳过日期) 强烈建议模拟盘使用真实价格成交, 即调用 set_option('use_real_price', True) . 更多细节请看 set_option 模拟交易和回测的差别 因为一些原因, 模拟交易现在和回测还是有些微小的差别, 具体如下: 市价单的处理: 回测: 成交量不会超过当天成交量(或当天成交量的一部分, 见order_volume_ratio 选项) 模拟: 默认使用盘口撮合，五档之后转撤销处理；关闭盘口撮合后，如果成交量不为0，则全部 成交 这会导致同样的日期同样的程序回测结果可能会和模拟交易结果不一样, 请注意 按天模拟交易暂时不支持限价单, 所有限价单会自动转成市价单 理论上对运行结果不会有影响: 模拟交易进程每天会重启(请看[模拟交易注意事项]). 回测进程一般不会 重启, 如果需要重启(比如机器宕机了) 也会做和模拟交易同样的处理. 期货交割日 期货持仓到交割日，没有手动交割，系统会以当天结算价平仓, 没有手续费, 不会有交易记录. 还券细则 T+1, 当日融的券当日不能还 还券时要扣除利息 直接还券时, 可以使用当日买入的券还(不受T+1限制), 且优先使用当日买入的券还 API介绍

## 第23页

注意事项 取数据函数其它函数目录中带有”” 标识的API是 "回测环境/模拟" 专用的API，不能在研究 模块中调用整个 jqdata 模块在研究环境与回测环境下都可以使用. 所有价格单位是元 时间表示: 所有时间都是北京时间, 时区:UTC+8 所有时间都是datetime.datetime对象 每日结束时自动撤销所有未完成订单 下文中提到 Context, SecurityUnitData, Portfolio, Position, Order 对象都是只读的, 尝试修改他们会报 错或者无效. 没有python基础的同学请注意, 有的函数的定义中, 某些参数是有值的, 这个值是参数的默认值, 这个参 数是可选的, 可以不传. 回测和模拟中，每日下单的最大数量为10000笔 如需使用分仓操作，请看账户分仓操作. 策略设置函数 set_benchmark - 设置基准 set_benchmark(security) 默认我们选定了沪深300指数的每日价格作为判断您策略好坏和一系列风险值计算的基准. 您也可以使 用set_benchmark指定其他股票/指数/ETF的价格作为基准注意：这个函数只能在initialize中调用 参数 security:股票/指数/ETF代码 返回 None 示例 set_benchmark('600000.XSHG') set_order_cost - 设置佣金/印花税 set_order_cost(cost, type, ref=None) 指定每笔交易要收取的手续费, 系统会根据用户指定的费率计算每笔交易的手续费 参数 cost: OrderCost 对象

## 第24页

open_tax，买入时印花税 (只股票类标的收取，基金与期货不收) close_tax，卖出时印花税 (只股票类标的收取，基金与期货不收) open_commission，买入时佣金 close_commission, 卖出时佣金 close_today_commission, 平今仓佣金 min_commission, 最低佣金，不包含印花税 type: 股票基金金融期货，’stock’/ ‘fund’ / ‘index_futures’ / ‘futures’ ref: 参考代码，支持股票代码/基金代码/期货合约代码，以及期货的品种，如 ‘000001.XSHE’/’510180.XSHG’/’IF1709’/’IF’ 默认与示例 # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱 set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='stock') # 期货类每笔交易时的手续费是：买入时万分之0.23,卖出时万分之0.23,平今仓为万分之23 set_order_cost(OrderCost(open_tax=0, close_tax=0, open_commission=0.000023, c lose_commission=0.000023, close_today_commission=0.0023, min_commission=0), t ype='index_futures') # 单独设置 000300.XSHG 的费用 set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='stock', ref='000300.XSHG') # 设置所有期货（包括金融指数期货）的费用 set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='futures') # 对 IF/IH/IC 三个品种有效 set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='index_futures') # 单独设置AU期货品种的费用 set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='futures', ref='AU') # 单独设置AU1709合约的费用 set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='futures', ref='AU1709') 注：期货持仓到交割日会以当天结算价平仓, 没有手续费, 不会有交易记录. set_slippage - 设置滑点

## 第25页

set_slippage(object) 设定滑点，回测/模拟时有效. 当您下单后, 真实的成交价格与下单时预期的价格总会有一定偏差, 因此我们加入了滑点模式来帮您更好的模 拟真实市场的表现. 我们暂时只支持固定滑点 固定滑点 当您使用固定滑点的时候, 我们认为您的落单的多少并不会影响您最后的成交价格. 您只需要指定一个价差, 当您下达一个买单指令的时候, 成交的价格等于当时(您执行order函数所在的单位时间)的平均价格加上价差的 一半；当您下达一个卖出指令的时候，卖出的价格等于当时的平均价格减去价差的一半. 价差可以设定为一个固定值或者按照百分比设定 固定值： 这个价差可以是一个固定的值(比如0.02元, 交易时加减0.01元), 设定方式为：FixedSlippage(0.02) 百分比： 这个价差可以是是当时价格的一个百分比(比如0.2%, 交易时加减当时价格的0.1%), 设定方式为： PriceRelatedSlippage(0.002) # 设定滑点为固定值 set_slippage(FixedSlippage(0.02)) # 设定滑点为百分比 set_slippage(PriceRelatedSlippage(0.002)) 注：如果您没有调用 set_slippage 函数, 系统默认的滑点是 PriceRelatedSlippage(0.00246) 设置动态复权(真实价格)模式 set_option('use_real_price', value) 该设定必须在initialize中调用 设置是否开启动态复权（真实价格）模式，原理讲解图示见帖子默认是False(主要是为了让旧的策略不会 出错). 是否开启动态复权模式对模拟交易是有影响的，详情参见这里 参数 value: True / False 示例 # 开启动态复权模式 set_option('use_real_price', True) 是否开启动态复权对于回测及模拟交易的影响： 1. 动态复权原理 2. 是否开启动态复权模式对模拟交易的影响

## 第26页

开启，value 值为 True: 回测过程中: 每天看到的当天的价格都是真实的(不复权的) 使用真实的价格下单, 交易详情和持仓详情里看到的都是真实价格 为了让编写代码简单, 通过history/attribute_history/get_price/SecurityUnitData.mavg/vwap 等 API 拿到的都是基于当天日期的前复权价格. 比如: 回测运行到了2015-01-01这一天, 那 么history(3, '1d', 'close') 取得的就是你穿越到2015-01-01这一天所看到的前复权价 格. 另一方面, 你在不同日期调用 history/attribute_history/get_price/SecurityUnitData.mavg/vwap 返回的价格可能是不一样的, 因 为我们在不同日期看到的前复权价格是不一样的. 所以不要跨日期缓存这些API返回的结果. 每到新的一天, 如果持仓中有股票发生了拆合或者分红或者其他可能影响复权因子的情形, 我们 会根据复权因子自动调整股票的数量, 如果调整后的数量是小数, 则向下取整到整数, 最后为了保 证context.portfolio.portfolio_value不变, context.portfolio.cash可能有略微调整. 注意事项: 如上所说, 不要跨日期缓存history/attribute_history/get_price这些API返回的结果 开启真实价格回测之后, 回测结果可能会之前不一样, 因为交易时买入数量必须是100的倍 数, 使用前复权价格和实际价格能买入的数量是不一样的. 如果想通过 history 拿到昨天的真实价格, 还是需要用取得价格除以factor, 因为可能今天 发生了拆合分红, 导致拿到的昨天的价格是相对于今天的前复权价格. python s = '000001.XSHE' df = attribute_history(s, 1, '1d', fields=['close', 'factor']) real_close = df['close'][-1] / df['factor'][-1]  关闭，value 值为 False: 此选项的核心是选定一个日期作为基准, 保证这个日期的价格是真实价格, 然 后调整其他日期的价格. 最终保证所有价格是连续的, 在回测或者模拟交易过程中不同日期看到的价格 是一致的. 下面分回测和模拟交易单独做介绍: 回测: 基准日期是建立回测的日期, 回测过程中所看到的所有价格都是基于此日期的前复权价格. 比如说, 我昨天跑了一个回测, 那么回测过程所有价格都是在昨天所看到的前复权价格. 这会导致 两个问题: 回测过程中使用了前复权价格下单, 这是违背真实场景的, 不能对接实盘的. 不同的日期建立的回测跑出来的结果可能会有差异, 因为如果这两次回测之间回测的股票 发生了拆合或者分红, 会导致回测中看到前复权价格会不一致. 模拟交易: 基准日期是建立模拟交易的日期, 模拟交易过程所看到的所有价格都是基于此日期调 整过的. 为了方便计算, 我举一个虚拟的例子: 某只股票在如下三个日期的实际价格和后复权因子 分别是: 日期价格后复权因子 ------ 2015-09-0111 2015-10-0122 2015-11-0144 - 如果你在 09-01 建立了一个模拟交易, 你在不同日期看到的所有价格都是 1 - 如果你在 10-01 建立了一个模拟交易, 你在不同日期看到的所有价格都是 2 - 如果你在 11-01 建立了一个模拟交易, 你在不同日期看到的所有价格都是 4 为了更好的模拟, 建议大家都设成 True. 将来对接实盘交易时, 此选项会强制设成 True 注意： 设置 use_real_price 为 True之后, 如下的按天回测的代码是不对的：

## 第27页

def initialize(context): g.cached_data = [] g.s = '000001.XSHE' def handle_data(content, data): g.cached_data.append(data) if len(g.cached_data) > 1: # 如果昨天收盘价比前天涨了5%, 则买入. 这是不对的, 如果昨天早上发生了拆合, 则 昨天和前天的股价不具可比性. if g.cached_data[-1][g.s].close > g.cached_data[-2][g.s].close * 1.05: order(g.s, 1000) 设置成交量比例 set_option('order_volume_ratio', value) 设定成交量比例，根据实际行情限制每个订单的成交量. 参数 value: value 是一个 float 值, 根据实际行情限制每个订单的成交量. 对于每一笔订单： 如果是市价单, 成交量不超过: 每日成交量 * value 如果是限价单, 限价单撮合时设定分价表中每一个价格的成交量的比率, 假设某一分钟分价 表如下: 价格成交量 ------ 10.0  10 10.1  11 10.2  12 撮合时, 按价格 10.0 成交 10 * value 股, 按价格 10.1 成交 11 * value 股, 按价 格 10.2 成交 12 * value 股 示例 # 设定成交量比例 set_option('order_volume_ratio', 0.25) # 成交量不超过总成交量的四分之一 设置是否开启盘口撮合模式 set_option('match_with_order_book', value) 设定是否使用盘口撮合模式. 此选项只对模拟盘生效，默认开启 参数

## 第28页

value: 默认开启 True，开启，使用盘口进行撮合，撮合方式详见订单处理 False，关闭，使用 Bar 进行撮合，撮合方式详见订单处理 set_universe(history专用) set_universe(security_list) 设置或者更新此策略要操作的股票池 context.universe. 请注意: 该函数现在只用于设定history函数的默认security_list, 除此之外并无其他用处 参数 security_list: 股票列表 返回 None 示例 set_universe(['000001.XSHE', '600000.XSHG']) set_commission(已废弃) set_commission(object) 指定每笔交易要收取的手续费, 系统会根据用户指定的费率计算每笔交易的手续费 次函数已废弃，请使用 set_order_cost - 设置佣金/印花税 参数 object: 一个PerTrade对象 PerTrade.buy_cost，买入时手续费 PerTrade.sell_cost，卖出时手续费 PerTrade.min_cost，最少的手续费 默认：PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5) 每笔交易时的手续费是, 买入时万分之三，卖出时万分之三加千分之一印花税, 每笔交易最低扣5块钱 获取数据函数 get_price - 获取历史数据 get_price(security, start_date=None, end_date=None, frequency='daily', fields =None, skip_paused=False, fq='pre', count=None)

## 第29页

获取一支或者多只股票的行情数据, 按天或者按分钟，这里在使用时注意 end_date 的设置， 不要引入未来的 数据 关于停牌: 因为此API可以获取多只股票的数据, 可能有的股票停牌有的没有, 为了保持时间轴的一致, 我们默认没有跳过停牌的日期, 停牌时使用停牌前的数据填充(请看 SecurityUnitData 的 paused 属性). 如想 跳过, 请使用 skip_paused=True 参数, 同时只取一只股票的信息 参数 security: 一支股票代码或者一个股票代码的list count: 与 start_date 二选一，不可同时使用. 数量, 返回的结果集的行数, 即表示获取 end_date 之前 几个 frequency 的数据 start_date: 与 count 二选一，不可同时使用. 字符串或者 datetime.datetime/datetime.date 对象, 开始 时间. 如果 count 和 start_date 参数都没有, 则 start_date 生效, 值是 ‘2015-01-01’. 注意: 当取分钟数据时, 时间可以精确到分钟, 比如: 传入 datetime.datetime(2015, 1, 1, 10, 0, 0) 或者 '2015-01-01 10:00:00' . 当取分钟数据时, 如果只传入日期, 则日内时间是当日的 00:00:00. 当取天数据时, 传入的日内时间会被忽略 end_date: 格式同上, 结束时间, 默认是’2015-12-31’, 包含此日期. 注意: 当取分钟数据时, 如果 end_date 只有日期, 则日内时间等同于 00:00:00, 所以返回的数据是不包括 end_date 这一天的. frequency: 单位时间长度, 几天或者几分钟, 现在支持’Xd’,’Xm’, ‘daily’(等同于’1d’), ‘minute’(等同 于’1m’), X是一个正整数, 分别表示X天和X分钟(不论是按天还是按分钟回测都能拿到这两种单位的数 据), 注意, 当X > 1时, fields只支持[‘open’, ‘close’, ‘high’, ‘low’, ‘volume’, ‘money’]这几个标准字段. 默认 值是daily fields: 字符串list, 选择要获取的行情数据字段, 默认是None(表示[‘open’, ‘close’, ‘high’, ‘low’, ‘volume’, ‘money’]这几个标准字段), 支持SecurityUnitData里面的所有基本属性,，包含：[‘open’, ’ close’, ‘low’, ‘high’, ‘volume’, ‘money’, ‘factor’, ‘high_limit’,’ low_limit’, ‘avg’, ’ pre_close’, ‘paused’] skip_paused: 是否跳过不交易日期(包括停牌, 未上市或者退市后的日期). 如果不跳过, 停牌时会使用停 牌前的数据填充(具体请看SecurityUnitData的paused属性), 上市前或者退市后数据都为 nan, 但要注 意: 默认为 False 当 skip_paused 是 True 时, 只能取一只股票的信息 fq: 复权选项: 'pre' : 前复权(根据’use_real_price’选项不同含义会有所不同, 参见set_option), 默认是前复权 None : 不复权, 返回实际价格 'post' : 后复权 返回 请注意, 为了方便比较一只股票的多个属性, 同时也满足对比多只股票的一个属性的需求, 我们在 security参数是一只股票和多只股票时返回的结构完全不一样 如果是一支股票, 则返回pandas.DataFrame对象, 行索引是datetime.datetime对象, 列索引是行情字段 名字, 比如’open’/’close’. 比如: get_price('000300.XSHG')[:2] 返回: open close high low volume money

## 第30页

2015-01-05 3566.09 3641.54 3669.04 3551.51 451198098.0 519849817448.0 00:00:00 2015-01-06 3608.43 3641.06 3683.23 3587.23 420962185.0 498529588258.0 00:00:00 如果是多支股票, 则返回pandas.Panel对象, 里面是很多pandas.DataFrame对象, 索引是行情字段 (open/close/…), 每个pandas.DataFrame的行索引是datetime.datetime对象, 列索引是股票代号. 比如 get_price(['000300.XSHG', '000001.XSHE'])['open'][:2] 返回: 000300.XSHG 000001.XSHE 2015-01-05 00:00:00 3566.09 13.21 2015-01-06 00:00:00 3608.43 13.09 示例 # 获取一支股票 df = get_price('000001.XSHE') # 获取000001.XSHE的2015年的按天数据 df = get_price('000001.XSHE', start_date='2015-01-01', end_date='2015-01-31 2 3:00:00', frequency='minute', fields=['open', 'close']) # 获得000001.XSHG的20 15年01月的分钟数据, 只获取open+close字段 df = get_price('000001.XSHE', count = 2, end_date='2015-01-31', frequency='da ily', fields=['open', 'close']) # 获取获得000001.XSHG在2015年01月31日前2个交易日 的数据 df = get_price('000001.XSHE', start_date='2015-12-01 14:00:00', end_date='201 5-12-02 12:00:00', frequency='1m') # 获得000001.XSHG的2015年12月1号14:00-2015 年12月2日12:00的分钟数据 # 获取多只股票 panel = get_price(get_index_stocks('000903.XSHG')) # 获取中证100的所有成分股的 2015年的天数据, 返回一个[pandas.Panel] df_open = panel['open'] # 获取开盘价的[pandas.DataFrame], 行索引是[datetime.d atetime]对象, 列索引是股票代号 df_volume = panel['volume'] # 获取交易量的[pandas.DataFrame] df_open['000001.XSHE'] # 获取平安银行的2015年每天的开盘价数据 history  - 获取历史数据 history(count, unit='1d', field='avg', security_list=None, df=True, skip_paus ed=False, fq='pre') 回测环境/模拟专用API 查看历史的行情数据 关于停牌: 因为获取了多只股票的数据, 可能有的股票停牌有的没有, 为了保持时间轴的一致, 我们默认没有跳 过停牌的日期, 停牌时使用停牌前的数据填充(请看SecurityUnitData的paused属性). 如想跳过, 请使用 skip_paused=True 参数

## 第31页

当取天数据时, 不包括当天的, 即使是在收盘后 参数 count: 数量, 返回的结果集的行数 unit: 单位时间长度, 几天或者几分钟, 现在支持’Xd’,’Xm’, X是一个正整数, 分别表示X天和X分钟(不论是 按天还是按分钟回测都能拿到这两种单位的数据), 注意, 当X > 1时, field只支持[‘open’, ‘close’, ‘high’, ‘low’, ‘volume’, ‘money’]这几个标准字段. field: 要获取的数据类型, 支持SecurityUnitData里面的所有基本属性,，包含：[‘open’, ’ close’, ‘low’, ‘high’, ‘volume’, ‘money’, ‘factor’, ‘high_limit’,’ low_limit’, ‘avg’, ’ pre_close’, ‘paused’] security_list: 要获取数据的股票列表 None 表示查询 context.universe 中所有股票的数据，context.universe 需要使用set_universe进 行设定，形如：set_universe([‘000001.XSHE’, ‘600000.XSHG’]) df: 若是True, 返回pandas.DataFrame, 否则返回一个dict, 具体请看下面的返回值介绍. 默认是True. 我们之所以增加df参数, 是因为pandas.DataFrame创建和操作速度太慢, 很多情况并不需要使用它. 为 了保持向上兼容, df默认是True, 但是如果你的回测速度很慢, 请考虑把df设成False. skip_paused: 是否跳过不交易日期(包括停牌, 未上市或者退市后的日期). 如果不跳过, 停牌时会使用停 牌前的数据填充(具体请看SecurityUnitData的paused属性), 上市前或者退市后数据都为 nan, 但要注 意: 默认为 False 如果跳过, 则行索引不再是日期, 因为不同股票的实际交易日期可能不一样 fq: 复权选项: 'pre' : 前复权(根据’use_real_price’选项不同含义会有所不同, 参见set_option), 默认是前复权 None : 不复权, 返回实际价格 'post' : 后复权 返回 df=True: pandas.DataFrame对象, 行索引是datetime.datetime对象, 列索引是股票代号. 比如: 如果当前时间是 2015-01-07, universe是[‘000300.XSHG’, ‘000001.XSHE’], history(2, '1d', 'open') 将返回: —000300.XSHG000001.XSHE ——— 2015-01-05 00:00:003566.0913.21 2015-01-06 00:00:003608.4313.09 关于numpy和pandas, 请看下面的第三方库介绍 df=False: dict, key是股票代码, 值是一个numpy数组numpy.ndarray, 对应上面的DataFrame的每一列, 例如 history(2, '1d', 'open', df=False) 将返回: python { '000300.XSHG': array([ 3566.09, 3608.43]), '000001.XSHE': array([ 13.21, 13.09]) }

## 第32页

示例 h = history(5, security_list=['000001.XSHE', '000002.XSHE']) h['000001.XSHE'] #000001(平安银行)过去5天的每天的平均价, 一个pd.Series对象, index 是datatime h['000001.XSHE'][-1] #000001(平安银行)昨天(数组最后一项)的平均价 h.iloc[-1] #所有股票在昨天的平均价, 一个pd.Series对象, index是股票代号 h.iloc[-1]['000001.XSHE'] #000001(平安银行)昨天(数组最后一项)的平均价 h.mean() # 取得每一列的平均值 ## set_universe 之后可以，调用 history 可以不用指定 security_list set_universe(['000001.XSHE']) # 设定universe history(5) # 获取universe中股票的过去5天(不包含今天)的每天的平均价 history(5, '1m') # 获取universe中股票的过去5分钟(不包含当前分钟)的每分钟的平均价 history(5, '1m', 'price') # 获取universe中股票的过去5分钟(不包含当前分钟)的每分钟 的平均价 history(5, '1m', 'volume') # 获取universe中股票的过去5分钟(不包含当前分钟)的每分钟 的交易额 history(5, '1m', 'price', ['000001.XSHE']) # 获取平安银行的过去5分钟(不包含当前分 钟)的每分钟的平均价 h = history(5, security_list=['000001.XSHE', '000002.XSHE'], df=False) h['000001.XSHE'] #h 是一个 dict，获取 h 中 000001.XSHE 对应的值 h['000001.XSHE'][0] #返回000001.XSHE最新一日的数据 h['000001.XSHE'][-1] #返回000001.XSHE第五天的数据 h['000001.XSHE'].sum() #对返回的五日数据求和 h['000001.XSHE'].mean() # 对返回的五日数据求平均 # 因为h本身是一个dict, 下列panda.DataFrame的特性将不可用: # h.illoc[-1] # h.sum() attribute_history  - 获取历史数据 attribute_history(security, count, unit='1d', fields=['open', 'close', 'high', 'low', 'volume', 'money'], skip_paused=True, df=True, fq='pre') 回测环境/模拟专用API 查看某一支股票的历史数据, 可以选这只股票的多个属性, 默认跳过停牌日期. 当取天数据时, 不包括当天的, 即使是在收盘后 参数 security: 股票代码 count: 数量, 返回的结果集的行数 unit: 单位时间长度, 几天或者几分钟, 现在支持 ‘Xd’, ‘Xm’, X是一个正整数, 分别表示X天和X分钟(不论是 按天还是按分钟回测都能拿到这两种单位的数据), 注意, 当 X > 1 时, field 只支持 [‘open’, ‘close’, ‘high’, ‘low’, ‘volume’, ‘money’] 这几个标准字段.

## 第33页

fields: 股票属性的list, 支持SecurityUnitData里面的所有基本属性，包含：[‘open’, ’ close’, ‘low’, ‘high’, ‘volume’, ‘money’, ‘factor’, ‘high_limit’,’ low_limit’, ‘avg’, ’ pre_close’, ‘paused’] skip_paused: 是否跳过不交易日期(包括停牌, 未上市或者退市后的日期). 如果不跳过, 停牌时会使用停 牌前的数据填充(具体请看SecurityUnitData的paused属性), 上市前或者退市后数据都为 nan, 默认是 True df: 若是True, 返回pandas.DataFrame, 否则返回一个dict, 具体请看下面的返回值介绍. 默认是True.我 们之所以增加df参数, 是因为pandas.DataFrame创建和操作速度太慢, 很多情况并不需要使用它. 为了 保持向上兼容, df默认是True, 但是如果你的回测速度很慢, 请考虑把df设成False. fq: 复权选项: 'pre' : 前复权(根据’use_real_price’选项不同含义会有所不同, 参见set_option), 默认是前复权 None : 不复权, 返回实际价格 'post' : 后复权 返回 df=True pandas.DataFrame对象, 行索引是datetime.datetime对象, 列索引是属性名字. 比如: 如果当前时间是 2015-01-07, attribute_history('000300.XSHG', 2) 将返回: open close high low volume money 2015-01-05 3566.09 3641.54 3669.04 3551.51 451198098.0 519849817448.0 00:00:00 2015-01-06 3608.43 3641.06 3683.23 3587.23 420962185.0 498529588258.0 00:00:00 df=False: dict, key是股票代码, 值是一个numpy数组numpy.ndarray, 对应上面的DataFrame的每一列, 例如 attribute_history('000300.XSHG', 2, df=False) 将返回: { 'volume': array([ 4.51198098e+08, 4.20962185e+08]), 'money': array([ 5.19849817e+11, 4.98529588e+11]), 'high': array([ 3669.04, 3683.23]), 'low': array([ 3551.51, 3587.23]), 'close': array([ 3641.54, 3641.06]), 'open': array([ 3566.09, 3608.43]) } 示例

## 第34页

stock = '000001.XSHE' h = attribute_history(stock, 5, '1d', ('open','close', 'volume', 'factor')) # 取得000001(平安银行)过去5天的每天的开盘价, 收盘价, 交易量, 复权因子 # 不管df等于True还是False, 下列用法都是可以的 h['open'] #过去5天的每天的开盘价, 一个pd.Series对象, index是datatime h['close'][-1] #昨天的收盘价 h['open'].mean() # 下面的pandas.DataFrame的特性, df=False时将不可用 # 行的索引可以是整数, 也可以是日期的各种形式: h['open']['2015-01-05'] h['open'][datetime.date(2015, 1, 5)] h['open'][datetime.datetime(2015, 1, 5)] # 按行取数据 h.iloc[-1] #昨天的开盘价和收盘价, 一个pd.Series对象, index是字符串:'open'/'close' h.iloc[-1]['open'] #昨天的开盘价 h.loc['2015-01-05']['open'] # 高级运算 h = h[h['volume'] > 1000000] # 只保留交易量>1000000股的行 h['open'] = h['open']/h['factor'] #让open列都跟factor列相除, 把价格都转化成原始价 格 h['close'] = h['close']/h['factor'] get_current_data  - 获取当前时间数据 get_current_data() 回测环境/模拟专用API 获取当前单位时间（当天/当前分钟）的涨跌停价, 是否停牌，当天的开盘价等 回测时, 通过 API 获取到的是前一个单位时间(天/分钟)的数据, 而有些数据, 我们在这个单位时间是知道的, 比 如涨跌停价, 是否停牌, 当天的开盘价. 我们添加了这个API用来获取这些数据. 参数 现在不需要传入, 即使传入了, 返回的 dict 也是空的, dict 的 value 会按需获取. 返回值 一个dict, 其中 key 是股票代码, value 是拥有如下属性的对象 last_price : 最新价 high_limit: 涨停价 low_limit: 跌停价 paused: 是否停止或者暂停了交易, 当停牌未上市或者退市后返回 True is_st: 是否是 ST(包括ST, *ST)，是则返回 True，否则返回 False day_open: 当天开盘价 name: 股票现在的名称, 可以用这个来判断股票当天是否是 ST, *ST, 是否快要退市 industry_code: 股票现在所属行业代码, 参见 行业概念数据

## 第35页

注意 为了加速, 返回的 dict 里面的数据是按需获取的, dict 初始是空的, 当你使用 current_data[security] 时(假设 current_data 是返回的 dict), 该 security 的数据才会被获取. 返回的结果只在当天有效, 请不要存起来到隔天再用 示例 def handle_data(context, data): current_data = get_current_data() print current_data print current_data['000001.XSHE'] print current_data['000001.XSHE'].paused print current_data['000001.XSHE'].day_open get_bars  - 获取历史数据 get_bars(security, count, unit='1d', fields=['date', 'open','high','low','close'], include_now=False) 回测环境/模拟专用API 获取各种时间周期的 bar 数据， bar 的分割方式与主流股票软件相同， 而且支持返回当前时刻所在 bar 的数 据 参数 security: 股票代码 count: 大于0的整数，表示获取bar的个数如果行情数据的bar不足count个，返回的长度则小于count 个数 unit: bar的时间单位, 支持如下周期：’1m’, ‘5m’, ‘15m’, ‘30m’, ‘60m’, ‘120m’, ‘1d’, ‘1w’, ‘1M’’1w’ 表示 一周，‘1M’ 表示一月 fields: 获取数据的字段， 支持如下值：’date’, ‘open’, ‘close’, ‘high’, ‘low’, ‘volume’, ‘money’ include_now: 取值True 或者False 表示是否包含当前bar, 比如策略时间是9:33，unit参数为5m， 如 果 include_now=True,则返回9:30-9:33这个分钟 bar 返回值 一个 numpy.ndarry 对象可以通过 array[‘close’] 的方式直接访问列数据 示例 array = get_bars('000001.XSHG', 5, unit='1d',fields=['open','close'],include_ now=False) array['close'] get_extras - 获取基金净值/期货结算价等

## 第36页

get_extras(info, security_list, start_date='2015-01-01', end_date='2015-12-3 1', df=True, count=None) 得到多只标的在一段时间的如下额外的数据: is_st: 是否是ST，是则返回 True，否则返回 False acc_net_value: 基金累计净值 unit_net_value: 基金单位净值 futures_sett_price: 期货结算价 futures_positions: 期货持仓量 参数 info: [‘is_st’, ‘acc_net_value’, ‘unit_net_value’, ‘futures_sett_price’, ‘futures_positions’] 中的一个 security_list: 股票列表 start_date/end_date: 开始结束日期, 同 get_price df: 返回pandas.DataFrame对象还是一个dict, 同 history count: 数量, 与 start_date 二选一, 不可同时使用, 必须大于 0. 表示取 end_date 往前的 count 个交易 日的数据 返回值 df=True: pandas.DataFrame对象, 列索引是股票代号, 行索引是datetime.datetime, 比如 get_extras('acc_net_value', ['510300.XSHG', '510050.XSHG'], start_date='2015- 12-01', end_date='2015-12-03') 返回: ---510300.XSHG510050.XSHG --------- 2015-12-01 00:00:001.3953.119 2015-12-02 00:00:001.44323.251 2015-12-03 00:00:001.45353.254 get_extras('is_st', ['000001.XSHE', '000018.XSHE'], start_date='2013-12-01', end_date='2013-12-03')返回: ---000001.XSHE000018.XSHE --------- 2013-12-02 00:00:00FalseTrue 2013-12-03 00:00:00FalseTrue df=False 一个dict, key是基金代号, value是numpy.ndarray, 比如get_extras('acc_net_value', ['510300.XSHG', '510050.XSHG'], start_date='2015-12-01', end_date='2015-12- 03', df=False) 返回: python { u'510050.XSHG': array([ 3.119, 3.251, 3.254]), u'510300.XSHG': array([ 1.395 , 1.4432, 1.4535]) } get_fundamentals - 查询财务数据

## 第37页

get_fundamentals(query_object, date=None, statDate=None) 查询财务数据，详细的数据字段描述请点击财务数据文档查看 date和statDate参数只能传入一个: 传入date时, 查询指定日期date收盘后所能看到的最近(对市值表来说, 最近一天, 对其他表来说, 最近一 个季度)的数据, 我们会查找上市公司在这个日期之前(包括此日期)发布的数据, 不会有未来函数. 传入statDate时, 查询 statDate 指定的季度或者年份的财务数据. 注意: 1. 由于公司发布财报不及时, 一般是看不到当季度或年份的财务报表的, 回测中使用这个数据可能 会有未来函数, 请注意规避. 2. 由于估值表每天更新, 当按季度或者年份查询时, 返回季度或者年份最后一天的数据 3. 由于“资产负债数据”这个表是存量性质的， 查询年度数据是返回第四季度的数据 4. 银行业券商保险专项数据只有年报数据，需传入statDate参数，当传入 date 参数 或 statDate 传入季度时返回空，请自行避免未来函数 当 date 和 statDate 都不传入时, 相当于使用 date 参数, date 的默认值下面会描述. 参数 query_object: 一个sqlalchemy.orm.query.Query对象, 可以通过全局的 query 函数获取 Query 对象 date: 查询日期, 一个字符串(格式类似’2015-10-15’)或者datetime.date/datetime.datetime对象, 可以是 None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别: 1. 回测模块: 默认值会随着回测日期变化而变化, 等于 context.current_dt 的前一天(实际生活中我 们只能看到前一天的财报和市值数据, 所以要用前一天) 2. 研究模块: 使用平台财务数据的最新日期, 一般是昨天. 如果传入的 date 不是交易日, 则使用这个日期之前的最近的一个交易日 statDate: 财报统计的季度或者年份, 一个字符串, 有两种格式: 1. 季度: 格式是: 年 + ‘q’ + 季度序号, 例如: ‘2015q1’, ‘2013q4’. 2. 年份: 格式就是年份的数字, 例如: ‘2015’, ‘2016’. 返回 返回一个 pandas.DataFrame, 每一行对应数据库返回的每一行(可能是几个表的联合查询结果的一行), 列索 引是你查询的所有字段 注意： 1. 为了防止返回数据量过大, 我们每次最多返回10000行 2. 当相关股票上市前退市后，财务数据返回各字段为空 示例

## 第38页

# 查询'000001.XSHE'的所有市值数据, 时间是2015-10-15 q = query( valuation ).filter( valuation.code == '000001.XSHE' ) df = get_fundamentals(q, '2015-10-15') # 打印出总市值 log.info(df['market_cap'][0]) # 获取多只股票在某一日期的市值, 利润 df = get_fundamentals(query( valuation, income ).filter( # 这里不能使用 in 操作, 要使用in_()函数 valuation.code.in_(['000001.XSHE', '600000.XSHG']) ), date='2015-10-15') # 选出所有的总市值大于1000亿元, 市盈率小于10, 营业总收入大于200亿元的股票 df = get_fundamentals(query( valuation.code, valuation.market_cap, valuation.pe_ratio, income.tota l_operating_revenue ).filter( valuation.market_cap > 1000, valuation.pe_ratio < 10, income.total_operating_revenue > 2e10 ).order_by( # 按市值降序排列 valuation.market_cap.desc() ).limit( # 最多返回100个 100 ), date='2015-10-15') # 使用 or_ 函数: 查询总市值大于1000亿元 **或者** 市盈率小于10的股票 from sqlalchemy.sql.expression import or_ get_fundamentals(query( valuation.code ).filter( or_( valuation.market_cap > 1000, valuation.pe_ratio < 10 ) ))

## 第39页

# 查询平安银行2014年四个季度的季报, 放到数组中 q = query( income.statDate, income.code, income.basic_eps, balance.cash_equivalents, cash_flow.goods_sale_and_service_render_cash ).filter( income.code == '000001.XSHE', ) rets = [get_fundamentals(q, statDate='2014q'+str(i)) for i in range(1, 5)] # 查询平安银行2014年的年报 q = query( income.statDate, income.code, income.basic_eps, cash_flow.goods_sale_and_service_render_cash ).filter( income.code == '000001.XSHE', ) ret = get_fundamentals(q, statDate='2014') get_fundamentals_continuously - 查询多日的财务数据 get_fundamentals_continuously(query_object, end_date=None,count=None) 查询财务数据，详细的数据字段描述请点击财务数据文档查看 参数 query_object: 一个sqlalchemy.orm.query.Query对象, 可以通过全局的 query 函数获取 Query 对象 date: 查询日期, 一个字符串(格式类似’2015-10-15’)或者datetime.date/datetime.datetime对象, 可以是 None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别: 1. 回测模块: 默认值会随着回测日期变化而变化, 等于 context.current_dt 的前一天(实际生活中我 们只能看到前一天的财报和市值数据, 所以要用前一天) 2. 研究模块: 使用平台财务数据的最新日期, 一般是昨天. 如果传入的 date 不是交易日, 则使用这个日期之前的最近的一个交易日 count: 获取 end_date 前 count 个日期的数据 返回 返回一个 pandas.Panel 示例

## 第40页

>>> q = query(valuation.turnover_ratio, valuation.market_cap, indicator.eps ).filter(valuation.code.in_(['000001.XSHE', '600000.XSHG'])) >>> panel = get_fundamentals_continuously(q, enddate='2018-01-01', count=5) >>> panel <class 'pandas.core.panel.Panel'> Dimensions: 3 (items) x 5 (major_axis) x 2 (minor_axis) Items axis: turnover_ratio to eps Major_axis axis: 2017-12-25 to 2017-12-29 Minor_axis axis: 000001.XSHE to 600000.XSHG >>> panel.minor_xs('600000.XSHG') turnover_ratio market_cap eps day 2017-12-25 0.0687 3695.4270 0.48 2017-12-26 0.0542 3710.1030 0.48 2017-12-27 0.1165 3704.2324 0.48 2017-12-28 0.0849 3680.7510 0.48 2017-12-29 0.0582 3695.4270 0.48 >>> panel.major_xs('2017-12-25') turnover_ratio market_cap eps code 000001.XSHE 0.9372 2275.0796 0.38 600000.XSHG 0.0687 3695.4270 0.48 >>> panel.xs('turnover_ratio',axis=0) # axis=0 表示 items axis; axis=1 表示 major axis; axis=2 表示 minor axis code 000001.XSHE 600000.XSHG day 2017-12-25 0.9372 0.0687 2017-12-26 0.6642 0.0542 2017-12-27 0.8078 0.1165 2017-12-28 0.9180 0.0849 2017-12-29 0.5810 0.0582 jy.run_query - 更多财务及宏观数据 from jqdata import jy jy.run_query(query_object) 查询聚源数据，详细的数据字段描述请点击聚源数据查看

## 第41页

参数 query_object: 一个sqlalchemy.orm.query.Query对象, 可以通过全局的query函数获取Query对象 返回 返回一个pandas.DataFrame, 每一行对应数据库返回的每一行, 列索引是你查询的所有字段 注意 1. 为了防止返回数据量过大, 我们每次最多返回3000行 2. 不能进行连表查询，即同时查询多张表内数据 示例 # 查询'股票基本信息表 - STK_STOCKINFO'的数据, 并返回前10条数据 from jqdata import jy df = jy.run_query(query(jy.LC_StockArchives).limit(10)) # 打印出公司名称 log.info(df['ChiName']) gta.run_query - 更多财务及宏观数据 from jqdata import gta gta.run_query(query_object) 查询国泰安数据，详细的数据字段描述请点击国泰安数据查看，数据库包括股票的深度数据银行财务宏 观数据等 注意未来函数，建议使用filter进行过滤； 需导入 jqdata 模块，即在策略或研究起始位置加入from jqdata import gta 参数 query_object: 一个sqlalchemy.orm.query.Query对象 (http://docs.sqlalchemy.org/en/rel_1_0/orm/query.html), 可以通过全局的query函数获取Query对象 返回 返回一个pandas.DataFrame, 每一行对应数据库返回的每一行, 列索引是你查询的所有字段 注意： 1. 为了防止返回数据量过大, 我们每次最多返回3000行 2. 不能进行连表查询，即同时查询多张表内数据 示例

## 第42页

# 查询'股票基本信息表 - STK_STOCKINFO'的数据, 并返回前10条数据 from jqdata import gta df = gta.run_query(query(gta.STK_STOCKINFO).limit(10)) # 打印出股票简称 log.info(df['SHORTNAME']) — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — # 选出所有的发行价格大于10元, 股票类别为A类的的股票,并返回前20条记录 from jqdata import gta df = gta.run_query(query( gta.STK_STOCKINFO ).filter( gta.STK_STOCKINFO.ISSUEPRICE > 10, gta.STK_STOCKINFO.SHARETYPE == 'A' ).limit(20)) — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — # 将国泰安数据取到的股票代码转化为聚宽所使用的代码形式 from jqdata import gta df = gta.run_query(query(gta.STK_STOCKINFO)) # 获取国泰安提供的6为股票代码 symbol = df['SYMBOL'][0] # 转化为带后缀的股票代码 stock_code = normalize_code(symbol) # symbol输出为'000971' # stock_code输出为'000971.XSHE' get_index_stocks - 获取指数成份股 get_index_stocks(index_symbol, date=None) 获取一个指数给定日期在平台可交易的成分股列表，请点击指数列表查看指数信息 参数 index_symbol: 指数代码 date: 查询日期, 一个字符串(格式类似’2015-10-15’)或者datetime.date/datetime.datetime对象, 可以是 None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别: 1. 回测模块: 默认值会随着回测日期变化而变化, 等于context.current_dt 2. 研究模块: 默认是今天 返回 返回股票代码的list 示例

## 第43页

# 获取所有沪深300的股票 stocks = get_index_stocks('000300.XSHG') log.info(stocks) get_industry_stocks - 获取行业成份股 get_industry_stocks(industry_code, date=None) 获取在给定日期一个行业的所有股票，行业分类列表见数据页面-行业概念数据 参数 industry_code: 行业编码 date: 查询日期, 一个字符串(格式类似’2015-10-15’)或者datetime.date/datetime.datetime对象, 可以是 None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别: 1. 回测模块: 默认值会随着回测日期变化而变化, 等于context.current_dt 2. 研究模块: 默认是今天 返回 返回股票代码的list 示例 # 获取计算机/互联网行业的成分股 stocks = get_industry_stocks('I64') get_concept_stocks - 获取概念成份股 get_concept_stocks(concept_code, date=None) 获取在给定日期一个概念板块的所有股票，概念板块分类列表见数据页面-行业概念数据 参数 concept_code: 概念板块编码 date: 查询日期, 一个字符串(格式类似’2015-10-15’)或者datetime.date/datetime.datetime对象, 可以是 None, 使用默认日期. 这个默认日期在回测和研究模块上有点差别: 1. 回测模块: 默认值会随着回测日期变化而变化, 等于context.current_dt 2. 研究模块: 默认是今天 返回 返回股票代码的list 示例 # 获取风力发电概念板块的成分股 stocks = get_concept_stocks('GN036')

## 第44页

get_all_securities - 获取所有标的信息 get_all_securities(types=[], date=None) 获取平台支持的所有股票基金指数期货信息 参数 types: list: 用来过滤securities的类型, list元素可选: ‘stock’, ‘fund’, ‘index’, ‘futures’, ‘etf’, ‘lof’, ‘fja’, ‘fjb’. types为空时返回所有股票, 不包括基金,指数和期货 date: 日期, 一个字符串或者 datetime.datetime/datetime.date 对象, 用于获取某日期还在上市的股票信 息. 默认值为 None, 表示获取所有日期的股票信息 返回 pandas.DataFrame, 比如:get_all_securities()[:2] 返回: display_name name start_date end_date type 000001.XSHE 平安银行 PAYH 1991-04-03 9999-01-01 stock 000002.XSHE 万 科Ａ WKA 1991-01-29 9999-01-01 stock display_name: 中文名称 name: 缩写简称 start_date: 上市日期 end_date: 退市日期，如果没有退市则为2200-01-01 type: 类型，stock(股票)，index(指数)，etf(ETF基金)，fja（分级A），fjb（分级B） 示例

## 第45页

def initialize(context): #获得所有股票列表 log.info(get_all_securities()) log.info(get_all_securities(['stock'])) #将所有股票列表转换成数组 stocks = list(get_all_securities(['stock']).index) #获得所有指数列表 get_all_securities(['index']) #获得所有基金列表 df = get_all_securities(['fund']) #获取所有期货列表 get_all_securities(['futures']) #获得etf基金列表 df = get_all_securities(['etf']) #获得lof基金列表 df = get_all_securities(['lof']) #获得分级A基金列表 df = get_all_securities(['fja']) #获得分级B基金列表 df = get_all_securities(['fjb']) #获得2015年10月10日还在上市的所有股票列表 get_all_securities(date='2015-10-10') #获得2015年10月10日还在上市的 etf 和 lof 基金列表 get_all_securities(['etf', 'lof'], '2015-10-10') get_security_info - 获取单个标的信息 get_security_info(code) 获取股票/基金/指数的信息. 参数 code: 证券代码 返回值 一个对象, 有如下属性:

## 第46页

- display_name: 中文名称 name: 缩写简称 start_date: 上市日期, [datetime.date] 类型 end_date: 退市日期， [datetime.date] 类型, 如果没有退市则为2200-01-01 type: 类型，stock(股票)，index(指数)，etf(ETF基金)，fja（分级A），fjb（分级B） parent: 分级基金的母基金代码 **示例** # 获取基金的母基金, 下面的判断为真. assert get_security_info('502050.XSHG').parent == '502048.XSHG' get_billboard_list - 获取龙虎榜数据 get_billboard_list(stock_list, start_date, end_date, count) 获取指定日期区间内的龙虎榜数据 **参数** stock_list: 一个股票代码的 list 当值为 None 时， 返回指定日期的所有股票 start_date:开始日期 end_date: 结束日期 count: 交易日数量， 可以与 end_date 同时使用， 表示获取 end_date 前 count 个交易日的数据(含 end_date 当日) **返回值** pandas.DataFrame， 各 column 的含义如下:

## 第47页

- code: 股票代码 day: 日期 direction: ALL 表示汇总，SELL 表示卖，BUY 表示买 abnormal_code: 异常波动类型 abnormal_name: 异常波动名称 sales_depart_name: 营业部名称 rank: 0 表示汇总， 15 表示买一到买5， 610 表示卖一到卖五 buy_value:买入金额 buy_rate:买入金额占比(买入金额/市场总成交额) sell_value:卖出金额 sell_rate:卖出金额占比(卖出金额/市场总成交额) net_value:净额(买入金额 - 卖出金额) amount:市场总成交额 **示例** # 在策略中获取前一日的龙虎榜数据 get_billboard_list(stock_list=None, end_date = context.previous_date, count =1) get_locked_shares - 获取限售解禁数据 get_locked_shares(stock_list, start_date, end_date, forward_count) 获取指定日期区间内的限售解禁数据 **参数** stock_list: 一个股票代码的 list start_date: 开始日期 end_date: 结束日期 forward_count: 交易日数量， 可以与 start_date 同时使用， 表示获取 start_date 到 forward_count 个 交易日区间的数据 **返回值** pandas.DataFrame， 各 column 的含义如下:

## 第48页

- day: 解禁日期 code: 股票代码 num: 解禁股数 rate1: 解禁股数/总股本 rate2: 解禁股数/总流通股本 **示例** # 在策略中获取个股未来500天的解禁情况 get_locked_shares(stock_list=['000001.XSHE', '000002.XSHE'], start_date=conte xt.current_dt, forward_count=500) jqdata.get_all_trade_days - 获取所有交易日 jqdata.get_all_trade_days() 获取所有交易日, 不需要传入参数, 返回一个包含所有交易日的 [numpy.ndarray], 每个元素为一个 [datetime.date] 类型. **注： 需导入 jqdata 模块，即在策略或研究起始位置加入import jqdata** jqdata.get_trade_days - 获取指定范围交易日 jqdata.get_trade_days(start_date=None, end_date=None, count=None) 获取指定日期范围内的所有交易日, 返回 [numpy.ndarray], 包含指定的 start_date 和 end_date, 默认返回至 datatime.date.today() 的所有交易日 **注： 需导入 jqdata 模块，即在策略或研究起始位置加入import jqdata** **参数** start_date: 开始日期, 与 count 二选一, 不可同时使用. str/datetime.date/datetime.datetime 对象 end_date: 结束日期, str/datetime.date/datetime.datetime 对象, 默认为 datetime.date.today() count: 数量, 与 start_date 二选一, 不可同时使用, 必须大于 0. 表示取 end_date 往前的 count 个交易 日，包含 end_date 当天 jqdata.get_money_flow - 获取资金流信息 jqdata.get_money_flow(security_list, start_date=None, end_date=None, fields=N one, count=None) 获取一只或者多只股票在一个时间段内的资金流向数据，仅包含股票数据，不可用于获取期货数据 **注： 需导入 jqdata 模块，即在策略或研究起始位置加入import jqdata** **参数** security_list: 一只股票代码或者一个股票代码的 list start_date: 开始日期, 与 count 二选一, 不可同时使用, 一个字符串或者 datetime.datetime/datetime.date 对象, 默认为平台提供的数据的最早日期

## 第49页

end_date: 结束日期, 一个字符串或者 datetime.date/datetime.datetime 对象, 默认为 datetime.date.today() count: 数量, 与 start_date 二选一，不可同时使用, 必须大于 0. 表示返回 end_date 之前 count 个交 易日的数据, 包含 end_date fields: 字段名或者 list, 可选. 默认为 None, 表示取全部字段, 各字段含义如下： 字段名含义备注 ------------ date日期--- sec_code股票代码--- change_pct涨跌幅(%)--- net_amount_main主力净额(万)主力净额 = 超大单净额 + 大单净额 net_pct_main主力净占比(%)主力净占比 = 主力净额 / 成交额 net_amount_xl超大单净额(万)超大单：大于等于50万股或者100万元的成交单 net_pct_xl超大单净占比(%)超大单净占比 = 超大单净额 / 成交额 net_amount_l大单净额(万)大单：大于等于10万股或则20万元且小于50万股或者100万元的成 交单 net_pct_l大单净占比(%)大单净占比 = 大单净额 / 成交额 net_amount_m中单净额(万)中单：大于等于2万股或者4万元且小于10万股或则20万元的成交 单 net_pct_m中单净占比(%)中单净占比 = 中单净额 / 成交额 net_amount_s小单净额(万)小单：小于2万股或者4万元的成交单 net_pct_s小单净占比(%)小单净占比 = 小单净额 / 成交额 返回 返回一个 pandas.DataFrame 对象，默认的列索引为取得的全部字段. 如果给定了 fields 参数, 则列索引与给 定的 fields 对应. 示例 # 获取一只股票在一个时间段内的资金流量数据 jqdata.get_money_flow('000001.XSHE', '2016-02-01', '2016-02-04') jqdata.get_money_flow('000001.XSHE', '2015-10-01', '2015-12-30', fields="chan ge_pct") jqdata.get_money_flow(['000001.XSHE'], '2010-01-01', '2010-01-30', ["date", "sec_code", "change_pct", "net_amount_main", "net_pct_l", "net_amount_m"]) — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — # 获取多只股票在一个时间段内的资金流向数据 jqdata.get_money_flow(['000001.XSHE', '000040.XSHE', '000099.XSHE'], '2010-01 -01', '2010-01-30') # 获取多只股票在某一天的资金流向数据 jqdata.get_money_flow(['000001.XSHE', '000040.XSHE', '000099.XSHE'], '2016-04 -01', '2016-04-01') — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — # 获取股票 000001.XSHE 在日期 2016-06-30 往前 20 个交易日的资金流量数据 jqdata.get_money_flow('000001.XSHE', end_date="2016-06-30", count=20) # 获取股票 000001.XSHE 往前 20 个交易日的资金流量数据 jqdata.get_money_flow('000001.XSHE', count=20)

## 第50页

jqdata.macro - 获取聚宽宏观经济数据 数据调用方法 from jqdata import macro macro.run_query(query_object) 参数 query_object: 一个sqlalchemy.orm.query.Query对象, 可以通过全局的query函数获取Query对象 返回 返回一个 dataframe， 每一行对应数据库返回的每一行， 列索引是你所查询的字段 注意 1. 为了防止返回数据量过大, 我们每次最多返回3000行 2. 不能进行连表查询，即同时查询多张表内数据 示例 # 查询分地区农林牧渔业总产值表(季度累计) 的前10条数据 q = query(macro.MAC_INDUSTRY_AREA_AGR_OUTPUT_VALUE_QUARTER ).limit(10) df = macro.run_query(q) # 查询2014年的分地区农林牧渔业总产值表(年度) q = query(macro.MAC_INDUSTRY_AREA_AGR_OUTPUT_VALUE_YEAR ).filter(macro.MAC_INDUSTRY_AREA_AGR_OUTPUT_VALUE_YEAR.stat_year=='20 14') df = macro.run_query(q) jqlib Alpha 101 因子 因子来源： 根据 WorldQuant LLC 发表的论文 101 Formulaic Alphas 中给出的 101 个 Alphas 因子公式，我们将公式编 写成了函数，方便大家使用 详细介绍： 函数计算公式API 调用方法，输入输出值详情请见:数据 - Alpha 101. 使用方法：

